"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasImportMatch = exports.getInnermostReturningFunction = exports.hasClosestExpectResolvesRejects = exports.getAssertNodeInfo = exports.getImportModuleName = exports.getFunctionName = exports.getReferenceNode = exports.getDeepestIdentifierNode = exports.getPropertyIdentifierNode = exports.getFunctionReturnStatementNode = exports.getInnermostFunctionScope = exports.getVariableReferences = exports.isPromiseHandled = exports.isPromisesArrayResolved = exports.isPromiseAllSettled = exports.isPromiseAll = exports.isPromiseIdentifier = exports.hasChainedThen = exports.isImportDeclaration = exports.isArrayExpression = exports.isReturnStatement = exports.isArrowFunctionExpression = exports.hasThenProperty = exports.isObjectExpression = exports.findClosestCallNode = exports.findClosestCallExpressionNode = exports.isExpressionStatement = exports.isJSXAttribute = exports.isProperty = exports.isObjectPattern = exports.isBlockStatement = exports.isImportDefaultSpecifier = exports.isImportNamespaceSpecifier = exports.isImportSpecifier = exports.isLiteral = exports.isMemberExpression = exports.isNewExpression = exports.isCallExpression = void 0;
const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const ValidLeftHandSideExpressions = [
    experimental_utils_1.AST_NODE_TYPES.CallExpression,
    experimental_utils_1.AST_NODE_TYPES.ClassExpression,
    experimental_utils_1.AST_NODE_TYPES.ClassDeclaration,
    experimental_utils_1.AST_NODE_TYPES.FunctionExpression,
    experimental_utils_1.AST_NODE_TYPES.Literal,
    experimental_utils_1.AST_NODE_TYPES.TemplateLiteral,
    experimental_utils_1.AST_NODE_TYPES.MemberExpression,
    experimental_utils_1.AST_NODE_TYPES.ArrayExpression,
    experimental_utils_1.AST_NODE_TYPES.ArrayPattern,
    experimental_utils_1.AST_NODE_TYPES.ClassExpression,
    experimental_utils_1.AST_NODE_TYPES.FunctionExpression,
    experimental_utils_1.AST_NODE_TYPES.Identifier,
    experimental_utils_1.AST_NODE_TYPES.JSXElement,
    experimental_utils_1.AST_NODE_TYPES.JSXFragment,
    experimental_utils_1.AST_NODE_TYPES.JSXOpeningElement,
    experimental_utils_1.AST_NODE_TYPES.MetaProperty,
    experimental_utils_1.AST_NODE_TYPES.ObjectExpression,
    experimental_utils_1.AST_NODE_TYPES.ObjectPattern,
    experimental_utils_1.AST_NODE_TYPES.Super,
    experimental_utils_1.AST_NODE_TYPES.ThisExpression,
    experimental_utils_1.AST_NODE_TYPES.TSNullKeyword,
    experimental_utils_1.AST_NODE_TYPES.TaggedTemplateExpression,
    experimental_utils_1.AST_NODE_TYPES.TSNonNullExpression,
    experimental_utils_1.AST_NODE_TYPES.TSAsExpression,
    experimental_utils_1.AST_NODE_TYPES.ArrowFunctionExpression,
];
function isCallExpression(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.CallExpression;
}
exports.isCallExpression = isCallExpression;
function isNewExpression(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === 'NewExpression';
}
exports.isNewExpression = isNewExpression;
function isMemberExpression(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.MemberExpression;
}
exports.isMemberExpression = isMemberExpression;
function isLiteral(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.Literal;
}
exports.isLiteral = isLiteral;
function isImportSpecifier(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.ImportSpecifier;
}
exports.isImportSpecifier = isImportSpecifier;
function isImportNamespaceSpecifier(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.ImportNamespaceSpecifier;
}
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
function isImportDefaultSpecifier(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.ImportDefaultSpecifier;
}
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
function isBlockStatement(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.BlockStatement;
}
exports.isBlockStatement = isBlockStatement;
function isObjectPattern(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.ObjectPattern;
}
exports.isObjectPattern = isObjectPattern;
function isProperty(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.Property;
}
exports.isProperty = isProperty;
function isJSXAttribute(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.JSXAttribute;
}
exports.isJSXAttribute = isJSXAttribute;
function isExpressionStatement(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.ExpressionStatement;
}
exports.isExpressionStatement = isExpressionStatement;
function findClosestCallExpressionNode(node, shouldRestrictInnerScope = false) {
    if (isCallExpression(node)) {
        return node;
    }
    if (!node || !node.parent) {
        return null;
    }
    if (shouldRestrictInnerScope &&
        !ValidLeftHandSideExpressions.includes(node.parent.type)) {
        return null;
    }
    return findClosestCallExpressionNode(node.parent, shouldRestrictInnerScope);
}
exports.findClosestCallExpressionNode = findClosestCallExpressionNode;
function findClosestCallNode(node, name) {
    if (!node.parent) {
        return null;
    }
    if (isCallExpression(node) &&
        experimental_utils_1.ASTUtils.isIdentifier(node.callee) &&
        node.callee.name === name) {
        return node;
    }
    else {
        return findClosestCallNode(node.parent, name);
    }
}
exports.findClosestCallNode = findClosestCallNode;
function isObjectExpression(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.ObjectExpression;
}
exports.isObjectExpression = isObjectExpression;
function hasThenProperty(node) {
    return (isMemberExpression(node) &&
        experimental_utils_1.ASTUtils.isIdentifier(node.property) &&
        node.property.name === 'then');
}
exports.hasThenProperty = hasThenProperty;
function isArrowFunctionExpression(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.ArrowFunctionExpression;
}
exports.isArrowFunctionExpression = isArrowFunctionExpression;
function isReturnStatement(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.ReturnStatement;
}
exports.isReturnStatement = isReturnStatement;
function isArrayExpression(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.ArrayExpression;
}
exports.isArrayExpression = isArrayExpression;
function isImportDeclaration(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === experimental_utils_1.AST_NODE_TYPES.ImportDeclaration;
}
exports.isImportDeclaration = isImportDeclaration;
function hasChainedThen(node) {
    const parent = node.parent;
    if (isCallExpression(parent) && parent.parent) {
        return hasThenProperty(parent.parent);
    }
    return !!parent && hasThenProperty(parent);
}
exports.hasChainedThen = hasChainedThen;
function isPromiseIdentifier(node) {
    return experimental_utils_1.ASTUtils.isIdentifier(node) && node.name === 'Promise';
}
exports.isPromiseIdentifier = isPromiseIdentifier;
function isPromiseAll(node) {
    return (isMemberExpression(node.callee) &&
        isPromiseIdentifier(node.callee.object) &&
        experimental_utils_1.ASTUtils.isIdentifier(node.callee.property) &&
        node.callee.property.name === 'all');
}
exports.isPromiseAll = isPromiseAll;
function isPromiseAllSettled(node) {
    return (isMemberExpression(node.callee) &&
        isPromiseIdentifier(node.callee.object) &&
        experimental_utils_1.ASTUtils.isIdentifier(node.callee.property) &&
        node.callee.property.name === 'allSettled');
}
exports.isPromiseAllSettled = isPromiseAllSettled;
function isPromisesArrayResolved(node) {
    const closestCallExpression = findClosestCallExpressionNode(node, true);
    if (!closestCallExpression) {
        return false;
    }
    return (!!closestCallExpression.parent &&
        isArrayExpression(closestCallExpression.parent) &&
        isCallExpression(closestCallExpression.parent.parent) &&
        (isPromiseAll(closestCallExpression.parent.parent) ||
            isPromiseAllSettled(closestCallExpression.parent.parent)));
}
exports.isPromisesArrayResolved = isPromisesArrayResolved;
function isPromiseHandled(nodeIdentifier) {
    const closestCallExpressionNode = findClosestCallExpressionNode(nodeIdentifier, true);
    const suspiciousNodes = [nodeIdentifier, closestCallExpressionNode].filter(Boolean);
    for (const node of suspiciousNodes) {
        if (!node || !node.parent) {
            continue;
        }
        if (experimental_utils_1.ASTUtils.isAwaitExpression(node.parent)) {
            return true;
        }
        if (isArrowFunctionExpression(node.parent) ||
            isReturnStatement(node.parent)) {
            return true;
        }
        if (hasClosestExpectResolvesRejects(node.parent)) {
            return true;
        }
        if (hasChainedThen(node)) {
            return true;
        }
        if (isPromisesArrayResolved(node)) {
            return true;
        }
    }
    return false;
}
exports.isPromiseHandled = isPromiseHandled;
function getVariableReferences(context, node) {
    var _a, _b;
    return ((experimental_utils_1.ASTUtils.isVariableDeclarator(node) &&
        ((_b = (_a = context.getDeclaredVariables(node)[0]) === null || _a === void 0 ? void 0 : _a.references) === null || _b === void 0 ? void 0 : _b.slice(1))) ||
        []);
}
exports.getVariableReferences = getVariableReferences;
function getInnermostFunctionScope(context, asyncQueryNode) {
    const innermostScope = experimental_utils_1.ASTUtils.getInnermostScope(context.getScope(), asyncQueryNode);
    if ((innermostScope === null || innermostScope === void 0 ? void 0 : innermostScope.type) === 'function' &&
        experimental_utils_1.ASTUtils.isFunction(innermostScope.block)) {
        return innermostScope;
    }
    return null;
}
exports.getInnermostFunctionScope = getInnermostFunctionScope;
function getFunctionReturnStatementNode(functionNode) {
    if (isBlockStatement(functionNode.body)) {
        const returnStatementNode = functionNode.body.body.find((statement) => isReturnStatement(statement));
        if (!returnStatementNode) {
            return null;
        }
        return returnStatementNode.argument;
    }
    else if (functionNode.expression) {
        return functionNode.body;
    }
    return null;
}
exports.getFunctionReturnStatementNode = getFunctionReturnStatementNode;
function getPropertyIdentifierNode(node) {
    if (experimental_utils_1.ASTUtils.isIdentifier(node)) {
        return node;
    }
    if (isMemberExpression(node)) {
        return getPropertyIdentifierNode(node.object);
    }
    if (isCallExpression(node)) {
        return getPropertyIdentifierNode(node.callee);
    }
    if (isExpressionStatement(node)) {
        return getPropertyIdentifierNode(node.expression);
    }
    return null;
}
exports.getPropertyIdentifierNode = getPropertyIdentifierNode;
function getDeepestIdentifierNode(node) {
    if (experimental_utils_1.ASTUtils.isIdentifier(node)) {
        return node;
    }
    if (isMemberExpression(node) && experimental_utils_1.ASTUtils.isIdentifier(node.property)) {
        return node.property;
    }
    if (isCallExpression(node)) {
        return getDeepestIdentifierNode(node.callee);
    }
    if (experimental_utils_1.ASTUtils.isAwaitExpression(node)) {
        return getDeepestIdentifierNode(node.argument);
    }
    return null;
}
exports.getDeepestIdentifierNode = getDeepestIdentifierNode;
function getReferenceNode(node) {
    if (node.parent &&
        (isMemberExpression(node.parent) || isCallExpression(node.parent))) {
        return getReferenceNode(node.parent);
    }
    return node;
}
exports.getReferenceNode = getReferenceNode;
function getFunctionName(node) {
    var _a, _b;
    return ((_b = (_a = experimental_utils_1.ASTUtils.getFunctionNameWithKind(node)
        .match(/('\w+')/g)) === null || _a === void 0 ? void 0 : _a[0].replace(/'/g, '')) !== null && _b !== void 0 ? _b : '');
}
exports.getFunctionName = getFunctionName;
function getImportModuleName(node) {
    if (isImportDeclaration(node) && typeof node.source.value === 'string') {
        return node.source.value;
    }
    if (isCallExpression(node) &&
        isLiteral(node.arguments[0]) &&
        typeof node.arguments[0].value === 'string') {
        return node.arguments[0].value;
    }
}
exports.getImportModuleName = getImportModuleName;
function getAssertNodeInfo(node) {
    const emptyInfo = { matcher: null, isNegated: false };
    if (!isCallExpression(node.object) ||
        !experimental_utils_1.ASTUtils.isIdentifier(node.object.callee)) {
        return emptyInfo;
    }
    if (node.object.callee.name !== 'expect') {
        return emptyInfo;
    }
    let matcher = experimental_utils_1.ASTUtils.getPropertyName(node);
    const isNegated = matcher === 'not';
    if (isNegated) {
        matcher =
            node.parent && isMemberExpression(node.parent)
                ? experimental_utils_1.ASTUtils.getPropertyName(node.parent)
                : null;
    }
    if (!matcher) {
        return emptyInfo;
    }
    return { matcher, isNegated };
}
exports.getAssertNodeInfo = getAssertNodeInfo;
function hasClosestExpectResolvesRejects(node) {
    if (isCallExpression(node) &&
        experimental_utils_1.ASTUtils.isIdentifier(node.callee) &&
        node.parent &&
        isMemberExpression(node.parent) &&
        node.callee.name === 'expect') {
        const expectMatcher = node.parent.property;
        return (experimental_utils_1.ASTUtils.isIdentifier(expectMatcher) &&
            (expectMatcher.name === 'resolves' || expectMatcher.name === 'rejects'));
    }
    if (!node.parent) {
        return false;
    }
    return hasClosestExpectResolvesRejects(node.parent);
}
exports.hasClosestExpectResolvesRejects = hasClosestExpectResolvesRejects;
function getInnermostReturningFunction(context, node) {
    const functionScope = getInnermostFunctionScope(context, node);
    if (!functionScope) {
        return;
    }
    const returnStatementNode = getFunctionReturnStatementNode(functionScope.block);
    if (!returnStatementNode) {
        return;
    }
    const returnStatementIdentifier = getDeepestIdentifierNode(returnStatementNode);
    if ((returnStatementIdentifier === null || returnStatementIdentifier === void 0 ? void 0 : returnStatementIdentifier.name) !== node.name) {
        return;
    }
    return functionScope.block;
}
exports.getInnermostReturningFunction = getInnermostReturningFunction;
function hasImportMatch(importNode, identifierName) {
    if (experimental_utils_1.ASTUtils.isIdentifier(importNode)) {
        return importNode.name === identifierName;
    }
    return importNode.local.name === identifierName;
}
exports.hasImportMatch = hasImportMatch;
